from abc import ABC, abstractmethod
from typing import List, Dict, Any
from enum import Enum


# Enum for controlled artifact types
class ArtifactType(Enum):
    ALIGNMENT_OUTPUT = "alignment_output"
    QC_METRICS = "qc_metrics"
    VARIANT_OUTPUT = "variant_output"
    OTHER = "other"


# Enum for controlled task types
class TaskType(Enum):
    ALIGNMENT = "alignment"
    SNV_CALLING = "snv_calling"
    SV_CALLING = "sv_calling"
    OTHER = "other"


class AbstractArtifact(ABC):
    """
    Abstract base class for artifacts generated by tasks.
    """
    def __init__(self, name: str, description: str, artifact_type: ArtifactType, size_per_x_cov: float, keep: bool):
        self.name = name
        self.description = description
        self.artifact_type = artifact_type
        self.size_per_x_cov = size_per_x_cov
        self.keep = keep

    @abstractmethod
    def calculate_storage_cost(self, genome_coverage: float, storage_rate: float) -> float:
        """
        Calculate the storage cost for this artifact.
        :param genome_coverage: Target genome coverage level.
        :param storage_rate: Rate of storage cost per unit size.
        :return: Total storage cost.
        """
        pass


class AbstractTask(ABC):
    """
    Abstract base class for tasks in a pipeline.
    """
    def __init__(self, name: str, description: str, task_type: TaskType, vcpu_min_per_x_cov: float):
        self.name = name
        self.description = description
        self.task_type = task_type
        self.vcpu_min_per_x_cov = vcpu_min_per_x_cov
        self.artifacts: List[AbstractArtifact] = []

    @abstractmethod
    def calculate_task_cost(self, genome_coverage: float, vcpu_cost_per_min: float) -> float:
        """
        Calculate the task cost based on coverage and vCPU cost per minute.
        :param genome_coverage: Target genome coverage level.
        :param vcpu_cost_per_min: Cost per vCPU-minute.
        :return: Total task cost.
        """
        pass
