#!/bin/bash

# Default region
region="us-west-2"  # Set the default region
fail_on_error=false  # Set default for fail on error

# Function to display help
usage() {
    echo "Usage: source $0 [--region REGION] [--fail-on-error]"
    echo "       --region REGION   Specify the AWS region (default: us-west-2)"
    echo "       --fail-on-warning   return as error  on warnings instead of continuing with warn msg. (default:false)"
}

# Check if script is sourced with no arguments
if [[ $# -eq 0 ]]; then
    usage
    return 0
fi

# Parse command-line arguments
while [[ $# -gt 0 ]]
do
key="$1"

case $key in
    --region)
    region="$2"
    shift # past argument
    shift # past value
    ;;
    --fail-on-error)
    fail_on_error=true
    shift # past argument
    ;;
    -h|--help)
    usage
    return 0
    ;;
    *)
    echo "Unknown option: $1"
    usage
    return 1
    ;;
esac
done

echo "Welcome to the Daylily CLI Setup"
echo "Daylily is configured to run in the $region region. You are advised to change your ~/.aws/config file to match this region."

# Check if the script is sourced
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    echo "This script should be sourced, not executed directly. Please use 'source $0' to run."
    return 1
fi

# Function to handle warnings
handle_warning() {
    local message="$1"
    echo -e "\nWARNING: $message"
    if $fail_on_error; then
        return 1
    else
        sleep 1.5
    fi
}

# Check AWS credentials
echo "Checking AWS credentials..."
if ! aws sts get-caller-identity --region $region &> /dev/null; then
    echo "Error: AWS credentials are not configured properly or do not have access to the AWS account in region $region. Exiting."
    return 1
else
    echo "AWS credentials are valid."
fi





# Get the caller identity ARN
## This bit not working for root users and hard to deubug solo. I'm moving the errors to warnings and will continue with the script.
caller_identity_arn=$(aws sts get-caller-identity --query 'Arn' --output text --region $region)

required_policies=(
    "pcluster-omics-analysis-fleet"
)

missing_policies=()

# If it's an IAM role, check attached policies for the role, otherwise check user policies
if [[ "$identity_type" == "IAM user" ]]; then
    user_policies=$(aws iam list-user-policies --user-name "$caller_identity_arn" --query 'PolicyNames' --output text --region $region)
    for policy_name in "${required_policies[@]}"; do
        if ! echo "$user_policies" | grep -wq "$policy_name"; then
            missing_policies+=("$policy_name")
        fi
    done
else
    role_name=$(echo "$caller_identity_arn" | awk -F'/' '{print $2}')
    role_policies=$(aws iam list-role-policies --role-name "$role_name" --query 'PolicyNames' --output text --region $region)
    for policy_name in "${required_policies[@]}"; do
        if ! echo "$role_policies" | grep -wq "$policy_name"; then
            missing_policies+=("$policy_name")
        fi
    done
fi

if [[ ${#missing_policies[@]} -gt 0 ]]; then
    echo "Error: The following required inline policies are missing from $identity_type '$current_user_name':"
    for policy in "${missing_policies[@]}"; do
        echo "  - $policy"
    done
    handle_warning  "\n\n\tWARNING! the *pcluster-omics-analysis-fleet* inline policy may be missing.\n\n"
    sleep 1.5
else
    echo "All required inline policies are attached to the $identity_type."
fi


# Check AWS quotas
echo "Checking AWS quotas..."
echo "EC2 On-Demand Standard (A, C, D, H, I, M, R, T, Z) instance limit\n"
# Example quota check: EC2 On-Demand Standard (A, C, D, H, I, M, R, T, Z) instance limit
quota_code="L-1216C47A"
quota=$(aws service-quotas get-service-quota --service-code ec2 --quota-code $quota_code --region $region)
if [[ $? -ne 0 ]]; then
    echo "Error: Unable to retrieve EC2 On-Demand Instance quota."
    return 1
fi

quota_value=$(echo $quota | jq -r '.Quota.Value')
if (( $(echo "$quota_value < 20" | bc -l) )); then
    echo "\n\n\tERROR: Your EC2 On-Demand Instance quota is less than the recommended value (20). Current quota: $quota_value"
    echo "You must request a quota increase."
    return 1
else
    echo "EC2 On-Demand Instance quota is sufficient: $quota_value"
fi


echo "All Standard (A, C, D, H, I, M, R, T, Z) Spot Instance Requests\n"
quota_code_2="L-34B43A08"
quota_2=$(aws service-quotas get-service-quota --service-code ec2 --quota-code $quota_code_2 --region $region)
if [[ $? -ne 0 ]]; then
    echo "Error: Unable to retrieve EC2 Spot Instance quota."
    return 1
fi

quota_value_2=$(echo $quota_2 | jq -r '.Quota.Value')
if (( $(echo "$quota_value_2 < 310" | bc -l) )); then
    echo "\n\n\tERROR: Your EC2 Spot Instance quota is less than the recommended value (310). Current quota: $quota_value_2"
    echo "You must request a quota increase."
    return 1
else
    echo "EC2 Spot Instance quota is sufficient: $quota_value_2"
fi




# Verify the required IAM policy 'pcluster-omics-analysis' exists and is attached
echo "Checking for required IAM policy 'pcluster-omics-analysis'..."

policy_name="pcluster-omics-analysis"
policy_arn=$(aws iam list-policies --query "Policies[?PolicyName=='$policy_name'].Arn" --output text --region $region)

if [[ -z "$policy_arn" ]]; then
    echo "IAM policy '$policy_name' does not exist. Creating policy..."
    policy_document='{
      "Version": "2012-10-17",
      "Statement": [
        {
          "Effect": "Allow",
          "Action": "iam:CreateServiceLinkedRole",
          "Resource": "*",
          "Condition": {
            "StringLike": {
              "iam:AWSServiceName": "spot.amazonaws.com"
            }
          }
        }
      ]
    }'
    aws iam create-policy --policy-name "$policy_name" --policy-document "$policy_document" --region $region
    if [[ $? -ne 0 ]]; then
        handle_warning  "\n\n\tWARNING: Unable to create IAM policy '$policy_name'. Please follow the steps in the quickstart guide to accomplish this manually."
        sleep 1.5
    fi
    policy_arn=$(aws iam list-policies --query "Policies[?PolicyName=='$policy_name'].Arn" --output text --region $region)
fi

# Check if the policy is attached to the current user
echo "Checking if IAM policy '$policy_name' is attached to the current user..."
attached_policies=$(aws iam list-attached-user-policies --user-name "$current_user_name" --query 'AttachedPolicies[].PolicyName' --output text --region $region)

if ! echo "$attached_policies" | grep -q "$policy_name"; then
    echo "Attaching policy '$policy_name' to user '$current_user_name'..."
    aws iam attach-user-policy --user-name "$current_user_name" --policy-arn "$policy_arn" --region $region
    if [[ $? -ne 0 ]]; then
        handle_warning  "\n\n\tWARNING: Unable to attach policy '$policy_name' to user '$current_user_name'. Please follow the instructions in the quickstart to h this policy."
        sleep 1.5
    fi
    echo "Policy '$policy_name' has been attached to user '$current_user_name'."
else
    echo "Policy '$policy_name' is already attached to user '$current_user_name'."
fi

# Check for required subnets and policy
echo "Checking for required subnets and policies..."

# Check for 'Public Subnet'
public_subnet_exists=$(aws ec2 describe-subnets --filters "Name=tag:Name,Values=*Public Subnet*" --query 'Subnets[0].SubnetId' --output text --region $region)
if [[ "$public_subnet_exists" == "None" ]]; then
    echo "Error: Subnet named 'Public Subnet' not found."
    echo "Please run the command: bin/init_cloudstackformation.sh ./config/day_cluster/pcluster_env.yml <short-prefix-to-use-for-cluster-resources>"
    return 1
else
    echo "Public Subnet found: $public_subnet_exists"
fi

# Check for 'Private Subnet'
private_subnet_exists=$(aws ec2 describe-subnets --filters "Name=tag:Name,Values=*Private Subnet*" --query 'Subnets[0].SubnetId' --output text --region $region)
if [[ "$private_subnet_exists" == "None" ]]; then
    echo "Error: Subnet named 'Private Subnet' not found."
    echo "Please run the command: bin/init_cloudstackformation.sh ./config/day_cluster/pcluster_env.yml <short-prefix-to-use-for-cluster-resources>"
    return 1
else
    echo "Private Subnet found: $private_subnet_exists"
fi

# Check for policy arn named 'pclusterTagsAndBudget'
policy_arn_pclusterTagsAndBudget=$(aws iam list-policies --query "Policies[?PolicyName=='pclusterTagsAndBudget'].Arn" --output text --region $region)
if [[ -z "$policy_arn_pclusterTagsAndBudget" ]]; then
    echo "Error: IAM policy named 'pclusterTagsAndBudget' not found."
    echo "Please run the command: bin/init_cloudstackformation.sh ./config/day_cluster/pcluster_env.yml <short-prefix-to-use-for-cluster-resources>"
    return 1
else
    echo "Policy 'pclusterTagsAndBudget' found: $policy_arn_pclusterTagsAndBudget"
fi

echo "All required subnets and policies are present."

# Proceed with the rest of the script

# Check if conda exists
if ! command -v conda &> /dev/null; then
    echo "Error: Conda is not available in this shell. EXITING." >&2
    return 1
fi

# Activate DAYCLI conda environment or create it if it doesn't exist
if conda env list | grep -q "^DAYCLI "; then
    echo "Conda environment 'DAYCLI' already exists. Activating it."
else
    echo "Creating 'DAYCLI' environment."
    conda create -y -n DAYCLI -c conda-forge python parallel nodejs==18.15.0 aws-parallelcluster==3.10.1 flask=2.2.5
fi
conda activate DAYCLI

# Check if parallel is installed
echo "Checking if GNU Parallel is installed..."
if ! parallel --version &> /dev/null; then
    echo "Error: GNU Parallel is not installed. Please install it (e.g., 'conda install -c conda-forge parallel'). Exiting."
    return 1
else
    echo "GNU Parallel found."
    # Citing parallel
    echo "Citing GNU parallel."
    parallel --citation <<< "will cite"   

    echo "We will absolutely cite gnu parallel when we publish our work."
    sleep 1
fi

# Ensure AWS CLI is installed
echo "Checking AWS CLI version..."
aws_version=$(aws --version 2>&1 | cut -d ' ' -f 1 | sed 's/aws\-cli\///g')
if [[ "$aws_version" != "1.27.92" ]]; then
    handle_warning "Warning: Expected AWS CLI version 1.27.92, but found version $aws_version."
fi

# Ensure pcluster is installed
echo "Checking pcluster version..."
pcluster_version=$(pcluster version | grep 'version' | cut -d '"' -f 4)
if [[ "$pcluster_version" != "3.5.0" ]]; then
    handle_warning  "Warning: Expected pcluster version 3.5.0, but found version $pcluster_version."
fi

# Prompt user for inputs
echo "Please enter the following required details:"

# Present available PEM files for user selection
pem_files=($(find ~/.ssh -type f -name "*.pem"))

if [[ ${#pem_files[@]} -eq 0 ]]; then
    echo "No PEM files found in ~/.ssh. Please ensure you have your PEM file there."
    return 1
fi
 
echo ""
echo "Select a PEM file to use:"
select pem_file in "${pem_files[@]}"; do
    if [[ -n "$pem_file" ]]; then
        echo "You selected: $pem_file"
        # Check if PEM file is of type ed25519
        key_type=$(ssh-keygen -l -f "$pem_file" 2>/dev/null | awk '{print $4}')
        if [[ "$key_type" != "ED25519" ]]; then
            handle_warning "\n\n\tWARNING: The selected PEM file MAY not be of type ed25519, which is required for Ubuntu hosts.\n"
            sleep 1.5
        else
            echo "PEM file is of type ed25519."
        fi
        break
    else
        echo "Invalid selection, please try again."
    fi
done


# Query available S3 buckets that match "omics-analysis"
matching_buckets=($(aws s3api list-buckets --query "Buckets[?contains(Name, 'omics-analysis')].Name" --output text --region $region))

if [[ ${#matching_buckets[@]} -eq 0 ]]; then
    echo "No S3 buckets matching 'omics-analysis' found. Please choose option 0 below."
    sleep 1

else
    bucket_url=na
    echo "\nSelect a matching S3 bucket or type 'm' to manually enter an S3 bucket:"
    options=("${matching_buckets[@]}")
    select bucket_choice in "Manually Enter s3 string" "${matching_buckets[@]}"; do
        if [[ "$REPLY" == "N" ]]; then
            echo -n "\nEnter the S3 bucket URL for references and init scripts (e.g., s3://BUCKET-NAME): "
            read bucket_url
            bucket_name=$(echo "$bucket_url" | sed 's/s3\:\/\///g' | sed 's/\/$//')

        elif [[ -n "$bucket_choice" ]]; then
            bucket_url="s3://$bucket_choice"
            bucket_name=$bucket_choice

        else
            echo "Invalid selection, please try again."
        fi
        echo "You selected: $bucket_url"
        break
    done
fi

echo "\n\n\tPUBLIC & PRIVATE subnets, as well as BUDGET POLICY ARN will be discovered automatically & should have been created by running the stackformation script previously. If nothing is presented, please run the stackformation and confirm the resources are being created.\n\n"
sleep 1

# Display public subnets with names and IDs for selection
echo "\nSelect a Public Subnet:"
public_subnets=$(aws ec2 describe-subnets \
  --query "Subnets[*].[SubnetId, Tags[?Key=='Name'].Value | [0]]" --region $region \
  --output text | grep "Public Subnet")

if [[ -z "$public_subnets" ]]; then
    echo "Error: No public subnets found. Exiting."
    return 1
fi
public_subnet_choices=()
while read -r subnet_id subnet_name; do
    public_subnet_choices+=("$subnet_name ($subnet_id)")
done <<< "$public_subnets"

select public_subnet_choice in "${public_subnet_choices[@]}"; do
    if [[ -n "$public_subnet_choice" ]]; then
        public_subnet=$(echo "$public_subnet_choice" | sed -n 's/.*(\(.*\)).*/\1/p')
        echo "You selected Public Subnet: $public_subnet"
        break
    else
        echo "Invalid selection, please try again."
    fi
done

# Select a Private Subnet:
private_subnets=$(aws ec2 describe-subnets \
  --query "Subnets[*].[SubnetId, Tags[?Key=='Name'].Value | [0]]" --region $region \
  --output text | grep "Private Subnet")
echo "\nSelect a Private Subnet:"

if [[ -z "$private_subnets" ]]; then
    echo "Error: No private subnets found. Exiting."
    return 1
fi

private_subnet_choices=()
while read -r subnet_id subnet_name; do
    private_subnet_choices+=("$subnet_name ($subnet_id)")
done <<< "$private_subnets"

select private_subnet_choice in "${private_subnet_choices[@]}"; do
    if [[ -n "$private_subnet_choice" ]]; then
        private_subnet=$(echo "$private_subnet_choice" | sed -n 's/.*(\(.*\)).*/\1/p')
        echo "You selected Private Subnet: $private_subnet"
        break
    else
        echo "Invalid selection, please try again."
    fi
done

# Query for all IAM policy ARNs that contain 'pclusterTagsAndBudget'
policy_arns=($(aws iam list-policies --query 'Policies[?PolicyName==`pclusterTagsAndBudget`].Arn' --output text --region $region))

if [[ ${#policy_arns[@]} -eq 0 ]]; then
    echo "Error: No IAM policies found with the name 'pclusterTagsAndBudget'. Exiting."
    return 1
fi

# Present the available IAM policies for user selection
echo "\nSelect an IAM policy ARN for 'pclusterTagsAndBudget':"
select arn_policy_id in "${policy_arns[@]}"; do
    if [[ -n "$arn_policy_id" ]]; then
        echo "You selected: $arn_policy_id"
        break
    else
        echo "Invalid selection, please try again."
    fi
done

# Cluster name input
echo -n "\nEnter the name for your cluster (alphanumeric and '-'): " 
read cluster_name
if [[ ! "$cluster_name" =~ ^[a-zA-Z0-9\-]+$ ]]; then
    echo "Error: Invalid cluster name. Only alphanumeric characters and hyphens are allowed."
    return 1
fi

# Daylily configuration file input
echo -n "\nEnter the path to the daylily cluster config YAML file [press Enter to use default 'config/day_cluster/prod_cluster.yaml']: "
read cluster_yaml

# Set default if no input is provided
if [[ -z "$cluster_yaml" ]]; then
    cluster_yaml="config/day_cluster/prod_cluster.yaml"
    echo "No path provided. Using default: $cluster_yaml"
fi

# Check if the YAML file exists
if [[ ! -f "$cluster_yaml" ]]; then
    echo "Error: YAML file '$cluster_yaml' does not exist. Exiting."
    return 1
fi

# XMR Mining Setup
echo ""
echo "Enable XMR mining with idle compute? Select 1 for No, 2 for Yes:"
select enable_xmr in "No" "Yes"; do
    case $REPLY in
        2)
            enable_xmr="1"
            # Prompt for the pool URL and wallet
            echo -n "Please specify a mining pool URL (default=pool.supportxmr.com:3333): "
            read xmr_pool_url
            if [[ -z "$xmr_pool_url" ]]; then
                xmr_pool_url="pool.supportxmr.com:3333"
            fi

            echo -n "Please specify a destination wallet (default=42s1tbj3qp6T2QBw9BzYxxRn1e9afiZhcRr8yoe2QYLn5ZG6Fk9XzEh1719moDeUgY6tReaJDF464ZhbEyg4cXMYNRXJve2, donates all coins to support human health/condition research.): "
            read xmr_wallet
            if [[ -z "$xmr_wallet" ]]; then
                xmr_wallet="42s1tbj3qp6T2QBw9BzYxxRn1e9afiZhcRr8yoe2QYLn5ZG6Fk9XzEh1719moDeUgY6tReaJDF464ZhbEyg4cXMYNRXJve2"
            fi

            # Check if the mining pool URL is reachable
            if ! nc -z $(echo "$xmr_pool_url" | cut -d: -f1) $(echo "$xmr_pool_url" | cut -d: -f2); then
                handle_warning "Cannot reach the mining pool URL: $xmr_pool_url"
            else
                echo "Mining pool URL is reachable."
            fi
            break
            ;;
        1)
            enable_xmr="0"
            xmr_pool_url="na"
            xmr_wallet="na"
            echo "XMR mining is disabled."
            break
            ;;
        *)
            echo "Invalid selection, please try again."
            ;;
    esac
done

# Create the Daylily configuration directory and copy the config file
mkdir -p ~/.config/daylily
target_conf=~/.config/daylily/${cluster_name}_cluster.yaml
regsub_vals=~/.config/daylily/${cluster_name}_cluster_init_vals.txt

cp "$cluster_yaml" "$target_conf"

# Prepare the replacement variables
pem_name=$(basename "$pem_file" | cut -d '.' -f 1)
echo """REGSUB_REGION=$region
REGSUB_PUB_SUBNET=$public_subnet
REGSUB_KEYNAME=$pem_name
REGSUB_S3_BUCKET_INIT=$bucket_url
REGSUB_S3_BUCKET_NAME=$bucket_name
REGSUB_S3_IAM_POLICY=$arn_policy_id
REGSUB_PRIVATE_SUBNET=$private_subnet
REGSUB_S3_BUCKET_REF=$bucket_url
REGSUB_XMR_MINE=$enable_xmr
REGSUB_XMR_POOL_URL=$xmr_pool_url
REGSUB_XMR_WALLET=$xmr_wallet
""" > $regsub_vals


sleep 0.25
bash bin/other/regsub_yaml.sh $regsub_vals $target_conf

# Run a dry run to validate the cluster creation
echo "Running a cluster creation dry run..."
pccmd="pcluster create-cluster -n $cluster_name -c $target_conf --dryrun true --region $region"

echo "running $pccmd"
pcluster create-cluster -n $cluster_name -c $target_conf --dryrun true --region $region

echo "\n\tPLEASE CONFIRM THE DRY RUN RETURNED WITH SUCCESS\n!!!!\n\t... then\n"
echo -n "\nAre you ready to create the cluster (y|n)? " 
read ready_to_create
if [[ "$ready_to_create" != "y" ]]; then
    echo "Exiting without creating the cluster."
    return 0
fi

# Create the cluster
echo "Creating the cluster '$cluster_name'... in region $region"
pccreate_cmd="pcluster create-cluster -n $cluster_name -c $target_conf --region $region"
echo "running $pccreate_cmd"

pcluster create-cluster -n $cluster_name -c $target_conf --region $region

# Monitoring cluster creation
echo "Waiting for the cluster to complete creation. This may take 10-15 minutes."
echo "You can monitor the status by running: pcluster list-clusters --region $region"

python bin/helpers/watch_cluster_status.py $region

echo "\n\n\tOnce the cluster status is COMPLETE, you can run './bin/daylily-init-headnode $pem_file' to configure the head node.\n\n"

echo " "
echo " "
echo "\n\tNext, configuring your head node.\n"
sleep 1
source bin/daylily-init-headnode $pem_file $region
