#!/bin/bash

# Default configuration
fail_on_error=false  # Default for error on warning

# Function to display help
usage() {
    echo "Usage: source $0 [--region REGION] [--fail-on-error]"
    echo "       --region REGION   Specify the AWS region (default: us-west-2)"
    echo "       --fail-on-error   Exit on warnings instead of continuing (default: false)"
}

# Check if script is sourced with no arguments
if [[ $# -eq 0 ]]; then
    usage
    return 0
fi

# Parse command-line arguments
while [[ $# -gt 0 ]]; do
    case "$1" in
        --region)
            region="$2"
            shift 2
            ;;
        --fail-on-error)
            fail_on_error=true
            shift
            ;;
        -h|--help)
            usage
            return 0
            ;;
        *)
            echo "Error: Unknown option: $1"
            usage
            return 1
            ;;
    esac
done

echo "Welcome to the Daylily CLI Setup"
echo "Daylily is configured to run in the $region region."
echo "Please ensure your ~/.aws/config file matches this region."

# Check if the script is sourced
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
    echo "Error: This script must be sourced, not executed directly. Use 'source $0' to run."
    return 1
fi

# Function to handle warnings
handle_warning() {
    local message="$1"
    echo -e "\nWARNING: $message"
    if $fail_on_error; then
        return 1
    else
        sleep 1.5
    fi
}

validate_region() {
  echo "RGN:" $1
  echo "NOTE:  you are advised to run _aws configure set region $1 _ to set the region for use with the pcluster CLI, to avoid the errors you will cause when the _region_ flag is not used."
  sleep 2.3

 if [[ "$1" == "us-west-2" ]]; then
    echo "Region '$1' confirmed as valid."
    return 0
  else
    handle_warning "Warning: Region '$1' is not 'us-west-2'."
    echo "It is recommended to use 'us-west-2' for this operation."
    sleep 2
    return 1
  fi
}

# Call the region validation function
validate_region "$region" || return 1

# Check AWS credentials
echo "Verifying AWS credentials..."
if ! aws sts get-caller-identity --region "$region" &> /dev/null; then
    echo "Error: AWS credentials are invalid or do not have access to the AWS account in region $region."
    return 1
else
    echo "AWS credentials verified successfully."
fi

# Get AWS caller identity
caller_identity_arn=$(aws sts get-caller-identity --query 'Arn' --output text --region "$region")
required_policies=("pcluster-omics-analysis-fleet")

# Check policies function
check_policies() {
    local entity_name="$1"
    local entity_type="$2"
    local policies=()

    if [[ "$entity_type" == "user" ]]; then
        policies=$(aws iam list-user-policies --user-name "$entity_name" --query 'PolicyNames' --output text --region "$region")
    else
        policies=$(aws iam list-role-policies --role-name "$entity_name" --query 'PolicyNames' --output text --region "$region")
    fi

    for policy_name in "${required_policies[@]}"; do
        if ! echo "$policies" | grep -wq "$policy_name"; then
            missing_policies+=("$policy_name")
        fi
    done
}

# IAM policy check (continue on warning for root users)
echo "Checking required policies for your AWS user/role..."
check_policies "$caller_identity_arn" "role"
if [[ ${#missing_policies[@]} -gt 0 ]]; then
    handle_warning "Missing required inline policies: ${missing_policies[*]}"
else
    echo "All required policies are attached."
fi

# AWS Quotas Check
echo "Checking AWS service quotas..."
quota_code="L-1216C47A"
quota=$(aws service-quotas get-service-quota --service-code ec2 --quota-code "$quota_code" --region "$region")
if [[ $? -ne 0 ]]; then
    echo "Error: Unable to retrieve EC2 quota."
    return 1
fi

quota_value=$(echo "$quota" | jq -r '.Quota.Value')
if (( $(echo "$quota_value < 20" | bc -l) )); then
    echo "Error: EC2 On-Demand Instance quota is below the recommended 20. Current quota: $quota_value"
    return 1
else
    echo "EC2 On-Demand Instance quota is sufficient: $quota_value"
fi

# Spot instance quota check
echo "Checking EC2 Spot Instance quota..."
quota_code_2="L-34B43A08"
quota_2=$(aws service-quotas get-service-quota --service-code ec2 --quota-code "$quota_code_2" --region "$region")
quota_value_2=$(echo "$quota_2" | jq -r '.Quota.Value')
if (( $(echo "$quota_value_2 < 310" | bc -l) )); then
    echo "Error: EC2 Spot Instance quota is below the recommended 310. Current quota: $quota_value_2"
    return 1
else
    echo "EC2 Spot Instance quota is sufficient: $quota_value_2"
fi

# Check for 'pcluster-omics-analysis' policy and create if necessary
echo "Checking for required IAM policy 'pcluster-omics-analysis'..."
policy_name="pcluster-omics-analysis"
policy_arn=$(aws iam list-policies --query "Policies[?PolicyName=='$policy_name'].Arn" --output text --region "$region")
if [[ -z "$policy_arn" ]]; then
    echo "Creating IAM policy '$policy_name'..."
    policy_document='{
      "Version": "2012-10-17",
      "Statement": [
        {
          "Effect": "Allow",
          "Action": "iam:CreateServiceLinkedRole",
          "Resource": "*",
          "Condition": {
            "StringLike": {
              "iam:AWSServiceName": "spot.amazonaws.com"
            }
          }
        }
      ]
    }'
    aws iam create-policy --policy-name "$policy_name" --policy-document "$policy_document" --region "$region"
fi

# Ensure Conda exists
if ! command -v conda &> /dev/null; then
    echo "Error: Conda is not available in this shell. Exiting."
    return 1
fi

# Activate or create the Daylily CLI conda environment
if conda env list | grep -q "^DAYCLI "; then
    echo "Conda environment 'DAYCLI' already exists. Activating it."
else
    echo "Creating 'DAYCLI' environment."
    conda create -y -n DAYCLI -c conda-forge python parallel nodejs==18.15.0 aws-parallelcluster==3.10.1 flask=2.2.5
fi
conda activate DAYCLI

# Check if GNU Parallel is installed
echo "Checking if GNU Parallel is installed..."
if ! parallel --version &> /dev/null; then
    echo "Error: GNU Parallel is not installed. Please install it (e.g., 'conda install -c conda-forge parallel'). Exiting."
    return 1
else
    echo "GNU Parallel found."
    parallel --citation <<< "will cite"
fi

# Ensure AWS CLI is installed
echo "Checking AWS CLI version..."
aws_version=$(aws --version 2>&1 | cut -d ' ' -f 1 | sed 's/aws\-cli\///g')
if [[ "$aws_version" != "1.27.92" ]]; then
    handle_warning "Warning: Expected AWS CLI version 1.27.92, but found version $aws_version."
fi

# Ensure pcluster is installed
echo "Checking pcluster version..."
pcluster_version=$(pcluster version | grep 'version' | cut -d '"' -f 4)
if [[ "$pcluster_version" != "3.5.0" ]]; then
    handle_warning "Warning: Expected pcluster version 3.5.0, but found version $pcluster_version."
fi

# Prompt user for PEM file selection
pem_files=($(find ~/.ssh -type f -name "*.pem"))

if [[ ${#pem_files[@]} -eq 0 ]]; then
    echo "No PEM files found in ~/.ssh. Please ensure you have your PEM file there."
    return 1
fi
 
echo ""
echo "Select a PEM file to use (you must have downloaded your ED25519 KEYNAME.pem file to ~/.ssh for it to appear here):"
select pem_file in "${pem_files[@]}"; do
    if [[ -n "$pem_file" ]]; then
        echo "You selected: $pem_file"
        key_type=$(ssh-keygen -l -f "$pem_file" 2>/dev/null | awk '{print $4}')
        if [[ "$key_type" != "ED25519" ]]; then
            handle_warning "The selected PEM file may not be of type ED25519, which is required for Ubuntu hosts."
        else
            echo "PEM file is of type ED25519."
        fi
        break
    else
        echo "Invalid selection, please try again."
    fi
done

# Query available S3 buckets that match "omics-analysis"
matching_buckets=($(aws s3api list-buckets --query "Buckets[?contains(Name, 'omics-analysis')].Name" --output text --region "$region"))

if [[ ${#matching_buckets[@]} -eq 0 ]]; then
    echo "No S3 buckets matching 'omics-analysis' found."
    sleep 1
else
    echo "Select a matching S3 bucket:"
    select bucket_choice in "${matching_buckets[@]}"; do
        bucket_url="s3://$bucket_choice"
        bucket_name=$bucket_choice
        echo "You selected: $bucket_url"
        break
    done
fi

# Select public and private subnets
echo "Select a Public Subnet:"
public_subnets=$(aws ec2 describe-subnets --query "Subnets[*].[SubnetId, Tags[?Key=='Name'].Value | [0]]" --region "$region" --output text | grep "Public Subnet")
public_subnet_choices=()
while read -r subnet_id subnet_name; do
    public_subnet_choices+=("$subnet_name ($subnet_id)")
done <<< "$public_subnets"

select public_subnet_choice in "${public_subnet_choices[@]}"; do
    public_subnet=$(echo "$public_subnet_choice" | sed -n 's/.*(\(.*\)).*/\1/p')
    echo "You selected Public Subnet: $public_subnet"
    break
done

echo "Select a Private Subnet:"
private_subnets=$(aws ec2 describe-subnets --query "Subnets[*].[SubnetId, Tags[?Key=='Name'].Value | [0]]" --region "$region" --output text | grep "Private Subnet")
private_subnet_choices=()
while read -r subnet_id subnet_name; do
    private_subnet_choices+=("$subnet_name ($subnet_id)")
done <<< "$private_subnets"

select private_subnet_choice in "${private_subnet_choices[@]}"; do
    private_subnet=$(echo "$private_subnet_choice" | sed -n 's/.*(\(.*\)).*/\1/p')
    echo "You selected Private Subnet: $private_subnet"
    break
done

# Select an IAM policy ARN for 'pclusterTagsAndBudget'
policy_arns=($(aws iam list-policies --query 'Policies[?PolicyName==`pclusterTagsAndBudget`].Arn' --output text --region "$region"))

echo "Select an IAM policy ARN for 'pclusterTagsAndBudget':"
select arn_policy_id in "${policy_arns[@]}"; do
    echo "You selected: $arn_policy_id"
    break
done

# Cluster name input
echo -n "Enter the name for your cluster (alphanumeric and '-'): "
read cluster_name
if [[ ! "$cluster_name" =~ ^[a-zA-Z0-9\-]+$ ]]; then
    echo "Error: Invalid cluster name."
    return 1
fi

# Cluster config file input
echo -n "Enter the path to the Daylily cluster config YAML file [press Enter to use default 'config/day_cluster/prod_cluster.yaml']: "
read cluster_yaml

if [[ -z "$cluster_yaml" ]]; then
    cluster_yaml="config/day_cluster/prod_cluster.yaml"
    echo "Using default: $cluster_yaml"
fi

if [[ ! -f "$cluster_yaml" ]]; then
    echo "Error: YAML file '$cluster_yaml' does not exist."
    return 1
fi 

# XMR Mining Setup
echo "Enable XMR mining with idle compute? (1) No (2) Yes:"
select enable_xmr in "No" "Yes"; do
    if [[ "$enable_xmr" == "Yes" ]]; then
        echo -n "Specify a mining pool URL (default=pool.supportxmr.com:3333): "
        read xmr_pool_url
        [[ -z "$xmr_pool_url" ]] && xmr_pool_url="pool.supportxmr.com:3333"

        echo -n "Specify a destination wallet (default wallet will donate coins to health research): "
        read xmr_wallet
        [[ -z "$xmr_wallet" ]] && xmr_wallet="42s1tbj3qp6T2QBw9BzYxxRn1e9afiZhcRr8yoe2QYLn5ZG6Fk9XzEh1719moDeUgY6tReaJDF464ZhbEyg4cXMYNRXJve2"

        if ! nc -z $(echo "$xmr_pool_url" | cut -d: -f1) $(echo "$xmr_pool_url" | cut -d: -f2); then
            handle_warning "Cannot reach the mining pool URL: $xmr_pool_url"
        else
            echo "Mining pool URL is reachable."
        fi
    else
        enable_xmr="0"
    fi
    break
done

# Prepare configuration
mkdir -p ~/.config/daylily
target_conf=~/.config/daylily/${cluster_name}_cluster.yaml
regsub_vals=~/.config/daylily/${cluster_name}_cluster_init_vals.txt

cp "$cluster_yaml" "$target_conf"
pem_name=$(basename "$pem_file" | cut -d '.' -f 1)

# Write variables to config
cat <<EOF > $regsub_vals
REGSUB_REGION=$region
REGSUB_PUB_SUBNET=$public_subnet
REGSUB_KEYNAME=$pem_name
REGSUB_S3_BUCKET_INIT=$bucket_url
REGSUB_S3_BUCKET_NAME=$bucket_name
REGSUB_S3_IAM_POLICY=$arn_policy_id
REGSUB_PRIVATE_SUBNET=$private_subnet
REGSUB_S3_BUCKET_REF=$bucket_url
REGSUB_XMR_MINE=$enable_xmr
REGSUB_XMR_POOL_URL=$xmr_pool_url
REGSUB_XMR_WALLET=$xmr_wallet
EOF

bash bin/other/regsub_yaml.sh $regsub_vals $target_conf

# Dry run cluster creation
echo "Running a cluster creation dry run..."
pcluster create-cluster -n "$cluster_name" -c "$target_conf" --dryrun true --region "$region"

echo -n "Are you ready to create the cluster (y/n)? "
read ready_to_create
if [[ "$ready_to_create" != "y" ]]; then
    echo "Exiting without creating the cluster."
    return 0
fi

# Create the cluster
echo "Creating the cluster '$cluster_name' in region $region"
pcluster create-cluster -n "$cluster_name" -c "$target_conf" --region "$region"

# Monitor cluster creation
echo "Monitoring cluster creation... this may take 10-15 minutes."
python bin/helpers/watch_cluster_status.py "$region"

echo "\nOnce the cluster is complete, configure the head node by running './bin/daylily-init-headnode $pem_file'."
echo "\n\t....trying this now!\n"
sleep 2
. ./bin/daylily-init-headnode $pem_file $regions